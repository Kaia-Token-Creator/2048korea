<!DOCTYPE html>
<html lang="ko">
<head>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9891583086388017" crossorigin="anonymous"></script>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2048 Korea</title>
<meta name="description" content="2048 Korea! ê³¼ì—° ë‹ˆê°€ ê¹° ìˆ˜ ìˆì„ê¹Œ?">

<!-- Open Graph (KakaoTalk ë“±) -->
<meta property="og:type" content="website">
<meta property="og:site_name" content="2048 Korea">
<meta property="og:title" content="2048 Korea! ê³¼ì—° ë‹ˆê°€ ê¹° ìˆ˜ ìˆì„ê¹Œ?">
<meta property="og:description" content="2048 Korea! ê³¼ì—° ë‹ˆê°€ ê¹° ìˆ˜ ìˆì„ê¹Œ?">
<meta property="og:url" content="https://Kaia-Token-Creator.github.io/2048korea">
<meta property="og:image" content="https://Kaia-Token-Creator.github.io/2048korea/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- X(Twitter) ì¹´ë“œ -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="2048 Korea! ê³¼ì—° ë‹ˆê°€ ê¹° ìˆ˜ ìˆì„ê¹Œ?">
<meta name="twitter:description" content="2048 Korea! ê³¼ì—° ë‹ˆê°€ ê¹° ìˆ˜ ìˆì„ê¹Œ?">
<meta name="twitter:image" content="https://Kaia-Token-Creator.github.io/2048korea/og-image.png">

<!-- íŒŒë¹„ì½˜/ì•± ì•„ì´ì½˜ -->
<link rel="icon" href="/favicon.ico">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<meta name="theme-color" content="#faf8ef">

<style>
  :root {
    --bg: #faf8ef;
    --board: #bbada0;
    --tile-empty: #cdc1b4;
    --text: #2b2b2b;
    --accent: #8f7a66;
    --tile-2: #eee4da; --tile-4: #ede0c8; --tile-8: #f2b179; --tile-16: #f59563; --tile-32: #f67c5f; --tile-64: #f65e3b;
    --tile-128: #edcf72; --tile-256: #edcc61; --tile-512: #edc850; --tile-1024: #edc53f; --tile-2048: #edc22e;
    --blue: #2563eb;
    --vh: 1vh; /* JSì—ì„œ ì‹¤ì œ ì•ˆì „ ë·°í¬íŠ¸ ë†’ì´ë¡œ ì—…ë°ì´íŠ¸ */
  }
  html, body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", AppleSDGothicNeo, Helvetica, Arial, sans-serif;
    height: auto;
  }

  /* âœ… í•œ í™”ë©´(ì „ì²´ ë†’ì´)ì— ê³ ì •, ìŠ¤í¬ë¡¤ ì°¨ë‹¨ */
  body { overflow: hidden; }
  #app {
    height: calc(var(--vh) * 100);
    max-width: 520px;
    margin: 0 auto;
    padding: 16px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    box-sizing: border-box;
  }
  @media (min-width: 768px){
    #app { max-width: 640px; }
  }

  /* ì „ì—­ ìŠ¤í¬ë¡¤/ì œìŠ¤ì²˜ ì°¨ë‹¨ ìœ ì§€ (ìš”ì²­ì‚¬í•­) */
  body, #app, .game-wrap, .board {
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;
    touch-action: none;
  }

  /* ===== ìƒë‹¨/í•˜ë‹¨ ì•ˆë‚´ ===== */
  .top-block { margin: 4px 0 8px; line-height: 1.5; }
  .top-link { margin: 0; font-size: clamp(12px, 3vw, 14px); }
  .top-link a { color: var(--blue); text-decoration: none; }
  .top-link a:hover { text-decoration: underline; }

  header { display:flex; justify-content: space-between; align-items: center; gap: 12px; }
  h1 { font-size: clamp(20px, 6vw, 36px); margin: 0; letter-spacing: 0.5px; }
  .badges { display:flex; gap: 8px; }
  .badge { background: #bbada0; color: #fff; padding: 8px 12px; border-radius: 10px; text-align:center; min-width: 84px; }
  .badge .label { font-size: 12px; opacity: .9; }
  .badge .val { font-size: 18px; font-weight: 700; }

  .btns { display:flex; gap: 8px; margin-top: 8px; }
  button { appearance:none; border: none; border-radius: 10px; padding: 10px 12px; background: #8f7a66; color:#fff; font-weight:700; cursor:pointer; }
  button:active { transform: translateY(1px); }

  /* ê²Œì„ ë˜í¼ëŠ” ìë™ ë†’ì´, ë³´ë“œëŠ” JSì—ì„œ ì •ì‚¬ê°ìœ¼ë¡œ í¬ê¸° ê³ ì • */
  .game-wrap { margin-top: 10px; display:flex; justify-content:center; }
  .board {
    background: var(--board);
    border-radius: 14px;
    position: relative;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    gap: clamp(6px, 1.4vw, 12px);
    padding: clamp(6px, 1.4vw, 12px);
    user-select: none;
    -webkit-user-select: none;
    overflow: hidden;
    /* width/heightëŠ” JSì—ì„œ ë™ì ìœ¼ë¡œ ì„¤ì • (ì •ì‚¬ê°) */
  }
  .cell { background: var(--tile-empty); border-radius: 10px; width: 100%; height: 100%; }

  .tile { position: absolute; inset: 0; margin: 0; }
  .tile > div {
    position: absolute;
    border-radius: 10px;
    display:flex; align-items:center; justify-content:center;
    font-weight: 800;
    font-size: clamp(18px, 5.2vw, 34px);
    color: #776e65;
    transition: transform 80ms ease-in, background-color 80ms linear, color 80ms linear;
  }

  .n-2, .n-4 { color: #776e65; }
  .n-8, .n-16, .n-32, .n-64, .n-128, .n-256, .n-512, .n-1024, .n-2048 { color: #f9f6f2; }

  .n-2 { background: var(--tile-2); }
  .n-4 { background: var(--tile-4); }
  .n-8 { background: var(--tile-8); }
  .n-16 { background: var(--tile-16); }
  .n-32 { background: var(--tile-32); }
  .n-64 { background: var(--tile-64); }
  .n-128 { background: var(--tile-128); }
  .n-256 { background: var(--tile-256); }
  .n-512 { background: var(--tile-512); }
  .n-1024 { background: var(--tile-1024); font-size: clamp(16px, 4.6vw, 30px); }
  .n-2048 { background: var(--tile-2048); font-size: clamp(14px, 4.2vw, 26px); }

  .overlay {
    position: absolute; inset: 0; display:none; align-items:center; justify-content:center;
    background: rgba(238, 228, 218, 0.73);
    border-radius: 14px; text-align:center; padding: 24px;
  }
  .overlay.show { display:flex; }
  .overlay h2 { margin: 0 0 8px; font-size: clamp(18px, 5.4vw, 28px); }
  .overlay p { margin: 0 0 14px; }

  .sr-only { position:absolute; left:-9999px; }

  /* ì´ë²¤íŠ¸ ë°•ìŠ¤/í•˜ë‹¨ ë§í¬ëŠ” í•œ í™”ë©´ì— ë“¤ì–´ì˜¤ë„ë¡ ì—¬ë°± ìµœì†Œí™” */
  .event-box { font-size: clamp(12px, 2.8vw, 14px); margin: 10px 0 8px; }
  .event-box .event-title { display:block; font-weight:700; margin-bottom:6px; }
  .event-box .highlight { color:#d9534f; }
  .below-cta { margin: 8px 0 0; text-align:left; font-size: clamp(12px, 2.8vw, 14px); }
  .below-cta a { color: var(--blue); text-decoration: none; font-weight: 600; }
  .below-cta a:hover { text-decoration: underline; }
</style>
</head>
<body>
  <div id="app" role="application" aria-label="2048 Game">
    <!-- ìƒë‹¨ ì•ˆë‚´ -->
    <div class="top-block" aria-label="ì‚¬ìš© ì•ˆë‚´">
      <p class="top-link">
        <a href="https://Kaia-Token-Creator.github.io/2048korea/vpn" target="_blank" rel="noopener">
          í˜¹ì‹œ? ìµëª…ìœ¼ë¡œ ì „ ì„¸ê³„ë¥¼ íƒí—˜í•˜ê³  ì‹¶ë‚˜ìš”?
        </a>
      </p>
    </div>

    <header>
      <h1>2048</h1>
      <div class="badges" aria-hidden="true">
        <div class="badge" id="scoreBox"><div class="label">SCORE</div><div class="val" id="score">0</div></div>
        <div class="badge" id="bestBox"><div class="label">BEST</div><div class="val" id="best">0</div></div>
      </div>
    </header>

    <div class="btns">
      <button id="newGame" aria-label="ìƒˆ ê²Œì„">ìƒˆ ê²Œì„</button>
      <button id="undoBtn" aria-label="ë˜ëŒë¦¬ê¸°">ë˜ëŒë¦¬ê¸°</button>
    </div>

    <!-- ê²Œì„ ì˜ì—­ -->
    <div class="game-wrap">
      <div class="board" id="board" tabindex="0" aria-label="ê²Œì„ ë³´ë“œ 4x4" aria-live="polite"></div>
      <div class="overlay" id="overlay" role="dialog" aria-modal="true">
        <div>
          <h2 id="ovTitle">ê²Œì„ ì¢…ë£Œ</h2>
          <p id="ovMsg">ë‹¤ì‹œ ë„ì „í•´ë³¼ê¹Œìš”?</p>
          <button id="retry">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
      </div>
    </div>

    <!-- ì´ë²¤íŠ¸ -->
    <div class="event-box">
      <strong class="event-title">2048 ìœ ì €ë¶„ë“¤ì—ê²Œ ë§¤ë‹¬ <span class="highlight">100ë§Œì›</span>ì„ ë“œë¦½ë‹ˆë‹¤</strong>
      <ol>
        <li>ì±„íŒ…ë°©(ê°œì¸/ë‹¨í†¡)ì´ë‚˜ SNS(ìœ íŠœë¸Œ, í‹±í†¡ í¬í•¨), ê²Œì‹œíŒ, ëŒ“ê¸€ ë“±ì— <strong>â€œì´ê±° ê¹° ìˆ˜ ìˆëŠ” ë¶„?â€</strong> ë©˜íŠ¸ì™€ í•¨ê»˜ <strong>www.2048korea.com</strong> ì •í™•í•œ ë§í¬ë¥¼ ê±¸ì–´ì£¼ì„¸ìš”.</li>
        <li><strong>2048korea@gmail.com</strong> ìœ¼ë¡œ ìŠ¤í¬ë¦°ìƒ·ê³¼ ê³„ì¢Œë²ˆí˜¸ë¥¼ ë³´ë‚´ì£¼ì„¸ìš”.</li>
        <li>ë§¤ë‹¬ í•œ ë¶„ ì¶”ì²¨ì„ í†µí•´ <strong>100ë§Œì›</strong>ì„ ë“œë¦½ë‹ˆë‹¤.</li>
      </ol>
      <p class="winner">ğŸ‰ 7ì›” ë‹¹ì²¨ì ê¹€íƒœ*ë‹˜ ì¶•í•˜ë“œë¦½ë‹ˆë‹¤!!</p>
    </div>

    <!-- í•˜ë‹¨ ë§í¬ -->
    <p class="below-cta">
      <a href="https://Kaia-Token-Creator.github.io/2048korea/exchange" target="_blank" rel="noopener">
        ì„¤ë§ˆ ì•„ì§ë„? êµ­ë‚´ê±°ë˜ì†Œ ì“°ê³  ê³„ì‹ ê°€ìš”?
      </a>
    </p>

    <p class="sr-only" id="status" aria-live="assertive"></p>
  </div>

<script>
/* ===== ì•ˆì „í•œ ë·°í¬íŠ¸ ë†’ì´ ë³€ìˆ˜ ì„¤ì • (ëª¨ë°”ì¼ ì£¼ì†Œì°½ ëŒ€ì‘) ===== */
function setSafeVH(){
  const vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
}
setSafeVH();
window.addEventListener('resize', setSafeVH);
window.addEventListener('orientationchange', setSafeVH);

/* ===== ë ˆì´ì•„ì›ƒ: í•œ í™”ë©´ì— ëª¨ë‘ ë“¤ì–´ê°€ë„ë¡ ë³´ë“œ í¬ê¸° ê³„ì‚° ===== */
function sizeBoard(){
  const app = document.getElementById('app');
  const boardEl = document.getElementById('board');
  const topBlock = document.querySelector('.top-block');
  const header = document.querySelector('header');
  const btns = document.querySelector('.btns');
  const eventBox = document.querySelector('.event-box');
  const belowCta = document.querySelector('.below-cta');

  // ì „ì²´ ë†’ì´(ì•ˆì „ ë·°í¬íŠ¸ ë†’ì´ ì‚¬ìš©)
  const appH = app.clientHeight;
  const appW = app.clientWidth;

  // ë³´ë“œ ì™¸ ìš”ì†Œ ë†’ì´ í•© (ë§ˆì§„ ì•½ê°„ ë³´ì •)
  const outsideH =
    (topBlock?.offsetHeight || 0) +
    (header?.offsetHeight || 0) +
    (btns?.offsetHeight || 0) +
    (eventBox?.offsetHeight || 0) +
    (belowCta?.offsetHeight || 0) +
    16; // ë‚´ë¶€ ì—¬ë°± ë³´ì •

  // ë³´ë“œì— ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë†’ì´/ë„ˆë¹„
  const availH = Math.max(0, appH - outsideH);
  const availW = appW - 0; // ì¢Œìš° paddingì€ #appì— í¬í•¨ë¨

  const size = Math.max(0, Math.min(availH, availW));

  // ì •ì‚¬ê° ë³´ë“œ ì‚¬ì´ì¦ˆ ì ìš©
  boardEl.style.width = size + 'px';
  boardEl.style.height = size + 'px';
}
window.addEventListener('load', () => {
  // í°íŠ¸ ë¡œë”© ì™„ë£Œ í›„ í•œ ë²ˆ ë” ê³„ì‚° (í…ìŠ¤íŠ¸ ë†’ì´ í™•ì •)
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(sizeBoard);
  }
  sizeBoard();
});
window.addEventListener('resize', sizeBoard);
window.addEventListener('orientationchange', sizeBoard);

/* ===== 2048 ê²Œì„ ë¡œì§ (ì›ë³¸ ìœ ì§€) ===== */
(function(){
  const SIZE = 4;
  const boardEl = document.getElementById('board');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovMsg = document.getElementById('ovMsg');
  const statusEl = document.getElementById('status');
  const newGameBtn = document.getElementById('newGame');
  const retryBtn = document.getElementById('retry');
  const undoBtn = document.getElementById('undoBtn');

  // âœ… ìŠ¤í¬ë¡¤ ì°¨ë‹¨ ìœ ì§€ (ìš”ì²­ì‚¬í•­)
  const stopScroll = (e) => { e.preventDefault(); };
  ['touchstart','touchmove','wheel'].forEach(evt => {
    boardEl.addEventListener(evt, stopScroll, { passive: false });
  });

  function buildCells(){
    boardEl.innerHTML = '';
    const frag = document.createDocumentFragment();
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        frag.appendChild(cell);
      }
    }
    boardEl.appendChild(frag);
  }

  let grid, score, best, history = [];

  function emptyGrid(){ return Array.from({length: SIZE}, () => Array(SIZE).fill(0)); }

  function start(newSeed=true){
    grid = emptyGrid();
    score = 0;
    updateScore(0);
    if (newSeed){ addRandomTile(); addRandomTile(); }
    history = [];
    render();
    hideOverlay();
    focusBoard();
    sizeBoard(); // ë³´ë“œ ìƒì„± ì§í›„ í•œë²ˆ ë” ë§ì¶¤
  }

  function focusBoard(){ boardEl.focus({preventScroll:true}); }

  function updateScore(plus){
    score += plus;
    scoreEl.textContent = score;
    best = Math.max(Number(localStorage.getItem('best2048')||'0'), score);
    localStorage.setItem('best2048', best);
    bestEl.textContent = best;
  }

  function randomEmptyCell(){
    const empties = [];
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (grid[r][c]===0) empties.push([r,c]);
    if (!empties.length) return null;
    return empties[Math.floor(Math.random()*empties.length)];
  }

  function addRandomTile(){
    const spot = randomEmptyCell();
    if (!spot) return false;
    const [r,c] = spot;
    grid[r][c] = Math.random() < 0.9 ? 2 : 4;
    return true;
  }

  function cloneGrid(g){ return g.map(row => row.slice()); }

  function canMove(){
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (grid[r][c]===0) return true;
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++){
      const v = grid[r][c];
      if (r+1<SIZE && grid[r+1][c]===v) return true;
      if (c+1<SIZE && grid[r][c+1]===v) return true;
    }
    return false;
  }

  function move(dir){
    const before = cloneGrid(grid);
    let moved = false; let gained = 0;

    function processLine(get, set){
      const vals = [];
      for (let i=0;i<SIZE;i++) vals.push(get(i));
      const filtered = vals.filter(v => v!==0);
      const merged = [];
      for (let i=0;i<filtered.length;i++){
        if (filtered[i+1] === filtered[i]){
          const nv = filtered[i]*2; gained += nv; merged.push(nv); i++;
        } else {
          merged.push(filtered[i]);
        }
      }
      while (merged.length < SIZE) merged.push(0);
      for (let i=0;i<SIZE;i++) set(i, merged[i]);
    }

    if (dir==='left'){
      for (let r=0;r<SIZE;r++){ processLine(i => grid[r][i], (i,v)=> grid[r][i]=v); }
    } else if (dir==='right'){
      for (let r=0;r<SIZE;r++){ processLine(i => grid[r][SIZE-1-i], (i,v)=> grid[r][SIZE-1-i]=v); }
    } else if (dir==='up'){
      for (let c=0;c<SIZE;c++){ processLine(i => grid[i][c], (i,v)=> grid[i][c]=v); }
    } else if (dir==='down'){
      for (let c=0;c<SIZE;c++){ processLine(i => grid[SIZE-1-i][c], (i,v)=> grid[SIZE-1-i][c]=v); }
    }

    moved = JSON.stringify(before)!==JSON.stringify(grid);
    if (moved){
      history.push({ grid: before, score });
      if (history.length>50) history.shift();
      updateScore(gained);
      addRandomTile();
      render();
      if (!canMove()) showOverlay('ê²Œì„ ì¢…ë£Œ', 'ë” ì´ìƒ ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
    announce(dir, moved, gained);
  }

  function undo(){
    const last = history.pop();
    if (!last) return;
    grid = cloneGrid(last.grid);
    score = last.score;
    scoreEl.textContent = score;
    render();
  }

  function announce(dir, moved, gained){
    const names = {left:'ì™¼ìª½', right:'ì˜¤ë¥¸ìª½', up:'ìœ„', down:'ì•„ë˜'};
    statusEl.textContent = moved ? `${names[dir]}ìœ¼ë¡œ ì´ë™, +${gained}ì ` : `ì´ë™ ì—†ìŒ`;
  }

  function hideOverlay(){ overlay.classList.remove('show'); }
  function showOverlay(title,msg){ ovTitle.textContent=title; ovMsg.textContent=msg; overlay.classList.add('show'); }

  function render(){
    if (!boardEl.querySelector('.cell')) buildCells();
    const old = boardEl.querySelector('.tile'); if (old) old.remove();
    const layer = document.createElement('div'); layer.className = 'tile';

    const g = getComputedStyle(boardEl);
    const G = parseFloat(g.gap);
    const P = parseFloat(g.padding);
    const cols = SIZE; const rows = SIZE;
    const rect = boardEl.getBoundingClientRect();
    const innerW = rect.width - P*2 - G*(cols-1);
    const innerH = rect.height - P*2 - G*(rows-1);
    const cw = innerW / cols; const ch = innerH / rows;

    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++){
      const v = grid[r][c]; if (!v) continue;
      const tile = document.createElement('div');
      tile.textContent = v;
      tile.className = `n-${v}`;
      tile.style.width = cw + 'px';
      tile.style.height = ch + 'px';
      tile.style.transform = `translate(${P + c*(cw+G)}px, ${P + r*(ch+G)}px)`;
      layer.appendChild(tile);
    }
    boardEl.appendChild(layer);
  }

  const keyMap = {
    'ArrowLeft':'left','a':'left','A':'left',
    'ArrowRight':'right','d':'right','D':'right',
    'ArrowUp':'up','w':'up','W':'up',
    'ArrowDown':'down','s':'down','S':'down'
  };
  window.addEventListener('keydown', (e)=>{
    const dir = keyMap[e.key];
    if (dir){ e.preventDefault(); move(dir); }
  }, { passive:false });

  let touchStartX=0, touchStartY=0, touching=false;
  const SWIPE_MIN = 18;
  boardEl.addEventListener('touchstart', (e)=>{
    if (!e.touches || !e.touches[0]) return;
    touching = true;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  }, { passive:false });
  boardEl.addEventListener('touchmove', (e)=>{
    if (touching) e.preventDefault();
  }, { passive:false });
  boardEl.addEventListener('touchend', (e)=>{
    if (!touching) return; touching=false;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX; const dy = t.clientY - touchStartY;
    if (Math.max(Math.abs(dx), Math.abs(dy)) < SWIPE_MIN) return;
    if (Math.abs(dx) > Math.abs(dy)) move(dx>0?'right':'left'); else move(dy>0?'down':'up');
  }, { passive:false });

  newGameBtn.addEventListener('click', () => window.location.reload());
  retryBtn.addEventListener('click', ()=> start(true));
  undoBtn.addEventListener('click', ()=> undo());

  window.addEventListener('resize', ()=> { sizeBoard(); render(); });
  window.addEventListener('orientationchange', ()=> { setTimeout(()=>{ setSafeVH(); sizeBoard(); render(); }, 100); });

  bestEl.textContent = Number(localStorage.getItem('best2048')||'0');
  start(true);
})();
</script>
</body>
</html>
